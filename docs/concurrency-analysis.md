# 동시성 제어 분석 보고서

## 개요
본 E-Commerce 시스템에서는 다수의 사용자가 동시에 잔액 충전, 주문, 재고 관리 및 쿠폰 발행과 같은 작업을 수행하면서 **유저 잔액**, **상품 재고**, **선착순 쿠폰 잔여 수량** 의 값에서 동시성 이슈가 발생할 가능성이 있다.
이러한 이슈는 데이터의 정합성을 해치고, 시스템 신뢰성을 저하시킬 수 있다.

이를 해결하기 위해 동시성 이슈의 발생 원인을 분석하고, 적절한 제어 방식을 도입하여 문제를 해결하고자 한다.
본 분석은 동시성 문제를 체계적으로 해결함으로써 시스템의 안정성과 신뢰성을 강화하는 것을 목표로 한다.

## Transaction Isolation Level

데이터베이스의 Transaction Isolation Level 은 트랜잭션 간의 격리 수준을 결정하여 동시성 문제를 제어하는 중요한 역할을 한다.
하지만 각 수준에 따라 발생할 수 있는 동시성 문제가 아래와 같이 존재한다.

### 1. Read Uncommitted
- **특징**: 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있다.
- **문제**: Dirty Read 발생 가능
    - **Dirty Read**: 한 트랜잭션이 아직 커밋되지 않은 데이터를 읽는 경우, 해당 데이터가 롤백되면 읽은 값이 잘못된 값이 될 수 있다.
- **장점**: 가장 낮은 격리 수준, 성능 우수
- **단점**: 데이터 정합성 ↓

### 2. Read Committed
- **특징**: 커밋된 데이터만 읽을 수 있다.
- **문제**: Non-Repeatable Read 발생 가능
    - **Non-Repeatable Read**: 같은 트랜잭션 내에서 동일한 데이터를 두 번 읽을 때, 다른 트랜잭션에서 데이터가 변경되어 읽는 값이 달라질 수 있다.
- **장점**: Dirty Read X
- **단점**: Non-Repeatable Read 발생

### 3. Repeatable Read
- **특징**: 트랜잭션이 시작된 이후 읽은 데이터는 트랜잭션이 끝날 때까지 변경되지 않는다.
- **문제**: Phantom Read 발생 가능
    - **Phantom Read**: 한 트랜잭션이 범위를 기반으로 쿼리를 수행한 후, 다른 트랜잭션이 해당 범위 내에 새로운 데이터를 추가하거나 삭제함으로써 결과가 달라질 수 있다.
- **장점**: Dirty Read X, Non-Repeatable Read X
- **단점**: Phantom Read 발생

### 4. Serializable
- **특징**: 모든 트랜잭션을 순서대로 실행하여 가장 높은 격리 수준을 제공한다.
- **문제**: 동시성 이슈가 발생하지 않는다.
- **장점**: Dirty Read X, Non-Repeatable Read X, Phantom Read X
- **단점**: 성능 저하가 심각, 높은 리소스 소비로 인해 대규모 트랜잭션 처리 X

Isolation Level 은 데이터 정합성과 성능 간의 Tradeoff 를 기반으로 선택해야 하며, 요구사항에 따라 적절한 수준을 설정해야 한다.

### Transaction Isolation Level 의 한계
- 높은 Level(ex. Serializable)은 데이터 정합성을 보장할 수 있지만, 성능 저하를 유발한다.
  특히 대규모 트래픽 환경에서는 트랜잭션 대기가 길어질 수 있다.
- 낮은 Level(ex. Read Committed, Repeatable Read)은 일부 동시성 문제(ex. Dirty Read, Non-Repeatable Read)를 해결할 수 있지만,
  Phantom Read 나 재고 초과 차감과 같은 문제는 방지할 수 없다.

### Lock 이 필요한 이유
- **특정 상황에서 강력한 정합성 보장**
  - 재고 관리나 쿠폰 발행과 같이 초과 처리를 방지해야 하는 경우에는 Lock 을 사용하여 단일 트랜잭션만 해당 데이터에 접근하도록 해야 한다.
- **세밀한 동시성 제어**
  - Lock 은 특정 비즈니스 로직에서 발생할 수 있는 동시성 문제를 세부적으로 제어할 수 있는 수단을 제공한다. Transaction Isolation Level 은 DB 레벨에서만 동작하지만, Lock 은 애플리케이션 레벨에서도 제어가 가능하다.
- **분산 환경 지원**
  - Transaction Isolation Level 은 단일 DB 에서만 동작한다. 하지만 Redis 분산 락과 같은 방법은 분산 시스템에서도 동시성 문제를 해결할 수 있다.
- **예시) 주문 생성 시 상품 재고 차감**
  - Transaction Isolation Level 를 Serializable 으로 사용할 경우
    - 데이터 정합성을 보장 가능하나, 다수의 요청이 발생할 때 모든 트랜잭션을 순차적으로 실행하여 병렬성을 극도로 제한하기 때문에 동시성이 낮아지고 대기시간이 증가할 수 있다.
  - Lock 을 사용할 경우
    - 동일한 상품 재고에 대해서 특정 레코드에만 Lock 을 걸기 때문에 시스템 성능과 동시성을 더 잘 조절할 수 있다.
    - 트랜잭션 단위가 아니라 레코드 단위로 Lock 을 걸거나 충돌을 감지하여 제어할 수 있다.

## 동시성 제어 방식

### 1. 애플리케이션 수준의 동시성 제어

**(1) Synchronized 블록**
- 특정 메서드나 코드 Block 에 대해 단일 스레드만 접근하도록 동기화
- **장점**
  - 구현이 단순하고 코드 레벨에서 관리가 가능하다.
- **단점**
  - 애플리케이션 분산 환경에서는 적용이 어렵다.
  - 특정 데이터 row 에 대한 동시성 처리에 한계가 있다. 
  - 병렬 처리가 감소한다.

**(2) ReentrantLock**
- lock(), unlock() 으로 시작과 끝을 명시하기 때문에 더 세밀한 Lock 제어가 가능하다.
- **장점**
  - 공정성 제어 및 타임아웃 설정이 가능하다.
- **단점**
  - 직접 Lock 해제가 필요하며, 구현 복잡성이 증가한다.
  - 분산 환경에서는 사용할 수 없다.

**(3) Redis 분산 락**
- Redis 를 이용하여 여러 인스턴스가 존재하는 분산 환경에서 Lock 을 관리한다.
- **장점**
  - 분산 환경에서 여러 인스턴스 간 Lock 공유가 가능하다.
  - Redisson 라이브러리를 활용하여 비교적 간단하게 구현할 수 있다.
- **단점**
  - Redis 서버 장애 시 문제가 발생할 수 있다.

### 2. DB 수준의 동시성 제어

**(1) 트랜잭션 격리 수준 (Transaction Isolation Level)**
- 데이터베이스 트랜잭션 격리 수준을 적절히 설정하여 동시성 문제를 방지할 수 있다.
- 일반적인 격리 수준:
  - **Read Uncommitted**: 가장 낮은 수준, Dirty Read 허용
  - **Read Committed**: Dirty Read 방지
  - **Repeatable Read**: Non-Repeatable Read 방지
  - **Serializable**: 가장 높은 수준, 모든 동시성 문제 방지 가능하나 성능 ↓

**(2) 낙관적 락(Optimistic Lock)**
- 데이터 수정 시 충돌 가능성을 허용하되, 최종 커밋 전에 Version 을 검증하여 충돌 여부를 판단하는 방식이다.
- 데이터에 Version 번호를 추가하고, 트랜잭션이 끝날 때 Version 번호를 확인하여 충돌 여부를 판단한다.
- **장점**
  - 읽기 작업이 많은 경우 성능이 우수하다
  - 충돌이 빈번하지 않을 때 효율적이다.
- **단점**
  - 충돌 발생 시 Retry 나 Rollback 이 필요하므로 추가 작업이 증가한다.
  - 충돌 빈도가 높으면 성능이 저하된다.

**(3) 비관적 락(Pessimistic Lock)**
- 트랜잭션이 실행 될 동안 데이터에 대해 잠금을 설정하여, 다른 트랜잭션이 접근하지 못하도록 제한한다.
- **장점**
  - 충돌을 사전에 방지한다.
  - 모든 요청이 성공해야 하는 경우에 효과적이다.
  - Lock 을 획득한 후 작업을 수행하고, 작업이 완료되면 Lock 을 해제하는 방식으로 구현이 단순하다.
- **단점**
  - 잠금으로 인한 성능 저하가 발생할 수 있다.

## 동시성 이슈

### 1. 결제 시 잔액 차감

- **문제점**
  - 동일한 사용자에 대해 동시에 잔액 충전 및 사용(주문) 요청이 이루어질 경우, 잔액 값이 예상치와 다르게 반영될 가능성이 있다.
  - 예를 들어, 잔액이 10,000원인 상태에서 충전 요청(+5,000원)과 주문 요청(-7,000원)이 동시에 발생하면, 요청 처리 순서에 따라 최종 잔액이 8,000원이 되지 않을 가능성이 있다.
- **목표**
  - 정확한 잔액 계산으로 데이터 정합성 보장
  - 성능 저하를 최소화 하며 동시성 문제를 해결
- **채택 방식**: 낙관적 락(Optimistic Lock)
- **이유**: 유저 테이블의 잦은 읽기 작업 발생 가능성이 있으며, 단일 유저의 작업으로 경합 가능성이 비교적 낮을 것으로 예상된다.

### 2. 주문 시 재고 차감

- **문제점**
  - 다수의 사용자가 동시에 같은 상품을 주문할 때 재고가 초과 차감될 가능성이 있다. 
  - 예를 들어, 남은 재고가 1개인데 두 사용자가 동시에 주문하면 최종 재고가 -1 이 될 수 있다.
- **목표**
  - 재고의 초과 차감을 방지
  - 모든 요청에 대한 정확한 재고 관리를 수행
- **채택 방식**: 비관적 락(Pessimistic Lock)
- **이유**: 여러 유저의 요청으로 경합이 발생할 가능성이 높고 대기 시간이 발생하더라도 모든 요청이 처리되어야 할 필요가 크므로, 강력한 정합성 보장이 필요하다.

### 3. 선착순 쿠폰 발행

- **문제점**
  - 쿠폰 발행 개수가 제한된 경우, 여러 사용자가 동시에 요청하면 제한 수량을 초과하여 발행될 가능성이 있다.
  - 예를 들어, 100개의 쿠폰만 제공 가능한 상황에서 200명의 사용자가 동시에 요청하면 100개를 초과하여 발행될 수 있다
- **목표**
  - 정확히 정해진 수량만 발행되도록 보장
  - 다중 사용자 요청 환경에서 성능과 안정성 확보
- **채택 방식**: Redis 분산 락
- **이유**: 쿠폰 발행은 주로 분산 환경에서 발생할 가능성이 높고, Lock 의 TTL 을 설정함으로써 데드락을 방지할 수 있다.
