# MSA 에서 트랜잭션 처리의 한계와 해결 방안

## **1. 개요**

서비스의 규모가 확장됨에 따라 단일 모놀리식 아키텍처에서 MSA (Microservices Architecture)로 전환이 필요하다.

MSA 에서는 각 도메인이 독립적으로 배포되지만, 트랜잭션이 여러 서비스에 걸쳐 발생할 경우 데이터 정합성을 보장하는 것이 어려워진다.

본 문서는 이러한 트랜잭션 처리의 한계와 해결 방안을 제시를 목표로 한다.

---

## **2. MSA 아키텍처의 트랜잭션 처리 한계**

### **2.1. 트랜잭션 일관성 유지의 어려움**

- 각 서비스는 독립적으로 운영되며, 네트워크를 통해 다른 서비스와 통신해야 하기 때문에 트랜잭션 일관성을 보장하는 것이 어렵다.
- 각 서비스가 개별 데이터베이스를 가지므로, 하나의 요청이 여러 서비스에 걸쳐 트랜잭션을 처리해야 하는 경우 ACID (Atomicity, Consistency, Isolation, Durability) 트랜잭션을 보장하기 어렵다.
- 예를 들어, 주문 서비스에서 주문 생성 후 결제 서비스에서 결제가 처리되기 전에 문제가 발생하면 일관성을 유지하기 어렵다.

### **2.2. 네트워크 장애 및 성능 저하 문제**

- 서비스 간 통신이 네트워크를 통해 이루어지므로, 일부 서비스가 장애가 발생하면 트랜잭션이 실패하거나 롤백이 어려울 수 있다.
- 분산 트랜잭션을 동기적으로 처리하면 서비스 간 네트워크 통신이 빈번해지고, 응답 속도가 느려질 수 있다.
- 특히 분산 트랜잭션을 위해 여러 서비스 간의 응답을 기다려야 하기 때문에 지연(latency)이 발생할 수 있다.

---

## **3. 해결 방안**

### **3.1. 2PC (Two-Phase Commit, 2단계 커밋 프로토콜) 기반 분산 트랜잭션**

**2PC(Two-Phase Commit)**는 분산 트랜잭션을 원자적으로 처리하는 프로토콜로, 중앙 조정자(Coordinator)가 모든 참여 서비스(트랜잭션 참여자)를 관리하여 트랜잭션을 조정하는 방식이다.

### **2PC의 단계**

1. **준비(Prepare) 단계**
  - Coordinator(중앙 조정자)가 각 참여 서비스(트랜잭션 참여자)에게 트랜잭션을 수행할 준비가 되었는지 요청(수행 가능 여부를 확인)
  - 각 참여 서비스는 트랜잭션을 실행하고 결과를 임시로 저장한 후 "준비 완료(Ready)" 응답을 보냄

2. **커밋(Commit) 단계**
  - 모든 참여 서비스가 "준비 완료(Ready)"를 응답하면, 중앙 조정자가 최종적으로 "커밋(Commit)" 명령을 내림
  - 일부 서비스가 실패하면 "롤백(Rollback)" 명령을 내리고, 모든 참여 서비스가 변경사항을 취소

### **2PC의 장점**
- **강한 일관성 보장**: 모든 서비스가 트랜잭션을 커밋하거나 롤백하므로 데이터 불일치가 발생 X
- **즉각적인 트랜잭션 반영**: 한 번의 트랜잭션 내에서 동기적으로 처리되므로, 즉각적인 데이터 일관성을 유지 가능

### **2PC의 단점**
- **성능 저하**: 모든 서비스가 커밋되기 전까지 다른 트랜잭션을 처리할 수 없어, 대기 시간이 길어질 수 있음
- **중앙 조정자 장애 문제**: Coordinator(중앙 조정자)가 장애를 일으키면 전체 트랜잭션이 중단될 수 있으며, 성능 저하 가능성 존재

### **2PC 적용 예시 (주문 생성 과정)**

1. **주문 서비스**가 주문 생성 요청을 받음
2. **조정자(Coordinator)**가 트랜잭션 참여자인 **상품 서비스, 쿠폰 서비스, 결제 서비스**에 "준비 요청(Prepare)"을 보냄
3. 각 서비스가 데이터베이스에 변경 사항을 반영할 준비가 되면 "준비 완료(Ready)"를 응답
4. 모든 서비스가 준비 완료를 응답하면 "커밋(Commit)"을 수행하여 데이터를 최종 반영

> 2PC 적용 시 고려 사항:
>
> - 성능 최적화를 위해 꼭 필요한 곳에서만 사용해야 한다.
> - 중앙 조정자가 장애를 일으키면 트랜잭션이 영구적으로 블로킹될 위험이 있으므로, **타임아웃 및 장애 복구 전략**을 수립해야 한다.

### **3.2. SAGA 패턴 (보상 트랜잭션 기반)**

2PC가 **즉각적인 데이터 일관성**을 유지하는 방식이라면, **SAGA 패턴은 최종적인 데이터 일관성(Eventual Consistency)**을 유지하는 방식이다.

SAGA 패턴에서는 각 서비스가 독립적인 **로컬 트랜잭션**을 수행하며, 실패 시 보상(Compensation) 트랜잭션을 실행하여 롤백하는 구조이다.

### **SAGA 의 두 가지 방식**

1. **Choreography 기반**
- 각 서비스가 이벤트를 수신하고, 필요한 작업을 수행한 후 다음 이벤트를 발행하는 방식
- 예:
  1. 주문 서비스가 주문 생성 후 `OrderCreated` 이벤트 발행
  2. 결제 서비스가 `OrderCreated` 이벤트를 수신하여 결제 처리
  3. 결제 완료 후 `PaymentSuccess` 이벤트 발행

2. **Orchestration 기반**

- 중앙에서 트랜잭션을 관리하는 **SAGA Coordinator(조정자)** 가 각 서비스의 트랜잭션을 순차적으로 실행하고, 실패 시 보상 트랜잭션을 실행하는 방식

### **SAGA 패턴 적용 예시** (주문 생성 과정)

1. 주문 서비스가 주문을 생성하고 `OrderCreated` 이벤트 발행
2. 상품 서비스가 이벤트를 수신하고 재고를 차감한 후 `StockReduced` 이벤트 발행
3. 쿠폰 서비스가 쿠폰을 사용한 후 `CouponUsed` 이벤트 발행
4. 결제 서비스가 잔액을 차감한 후 `PaymentCompleted` 이벤트 발행
5. 트랜잭션 중 하나라도 실패하면, 이전 서비스에서 보상 트랜잭션을 실행하여 데이터를 원상복구

### **SAGA 의 장점**

- **높은 확장성**: 2PC 보다 높은 확장성을 가지며, 각 서비스가 독립적으로 처리되므로 Coordinator 장애 시에도 성능 저하가 적음
- **부분 실패 복구 가능**: 실패한 서비스만 보상 트랜잭션을 실행하여 전체 시스템이 중단되지 않음

### **SAGA 의 단점**

- **즉각적인 일관성 보장 어려움**: 최종적으로 일관성을 맞추는 구조이므로, 중간 상태에서 데이터 불일치 가능성이 있음
- **보상 트랜잭션 비용 증가**: 보상 트랜잭션을 별도로 설계해야 하며, 일관성 유지에 대한 추가적인 로직 필요


### **3.3. 이벤트 기반 트랜잭션 (Outbox 패턴 & CDC(Change Data Capture))**

Kafka, RabbitMQ 등의 메시지 브로커를 이용하여 이벤트 기반으로 트랜잭션을 처리할 수도 있다.

각 서비스가 이벤트를 발행하고 소비함으로써, 데이터를 비동기적으로 업데이트하며 최종적인 데이터 일관성을 유지한다.

- **Outbox 패턴**: 데이터베이스 내 별도 테이블에 이벤트를 기록한 후, 이벤트 브로커(Kafka, RabbitMQ 등)로 전송
- **CDC(Change Data Capture)**: 데이터베이스 변경 사항을 감지하여 이벤트를 발행
- **장점**: 서비스 간 결합도를 낮추고, 장애 발생 시 데이터 유실을 최소화
- **단점**: 최종적 일관성(Eventual Consistency)을 유지해야 하므로, 실시간 일관성이 필요할 경우 적합하지 않음
- **적용 가능 영역**: 주문 생성 후 재고 차감, 쿠폰 사용 후 결제 요청 등의 비동기 트랜잭션

### **3.4 Idempotency(멱등성) 보장**

- 멱등성을 보장하면, 동일한 요청이 여러 번 전달되더라도 결과가 변하지 않기 때문에 재시도 및 중복 처리에 강한 시스템을 구축할 수 있다.
- 예를 들어, 결제 서비스에서 결제 처리 요청이 여러 번 들어와도, 결과는 동일해야 하므로, **결제 처리**는 멱등성을 보장하는 방식으로 설계해야 한다.

### **3.5 분산 트랜잭션을 위한 데이터 일관성**

---

## **4. 서비스별 트랜잭션 처리 방식**

### **4.1. 유저 서비스**

- **유저 잔액 충전**: 단일 서비스 내에서 완료되므로 트랜잭션 문제 X
- **유저 잔액 조회**: 단일 서비스 내에서 완료되므로 트랜잭션 문제 X

### **4.2. 상품 서비스**

- **상품 목록 조회**: 독립적인 서비스 내에서 처리 가능
- **상위 상품 조회**: 주문 서비스에서 발생한 이벤트(주문 완료 이벤트)를 기반으로 상품의 판매 데이터를 갱신할 수 있음

### **4.3. 주문 서비스**

- **주문 생성**: 유저 서비스, 상품 서비스, 쿠폰 서비스와 연계하여 처리
    - **트랜잭션 처리**: 이벤트 기반으로 주문 생성 후 관련 서비스에서 비동기적으로 트랜잭션 수행
    - **SAGA 패턴**을 활용하여 보상 트랜잭션을 정의하여 실패 시 롤백 가능하도록 설계

### **4.4. 결제 서비스**

- **결제 처리**: 유저 잔액 확인 후 결제 처리 후 주문 상태를 변경
    - **보상 트랜잭션**: 결제 실패 시 상태를 원복하거나 별도의 오류 로그 기록

### **4.5. 쿠폰 서비스**

- **쿠폰 발급** 및 **쿠폰 사용**: 유저 서비스와 연계하여 쿠폰 데이터를 갱신하며, 이벤트 기반(결제 완료 및 주문 취소 이벤트)으로 주문 및 결제 서비스와 연동

---

## **5. 해결 방안 비교 및 적용 전략**

| 해결 방안  | 데이터 일관성 | 성능  | 복구 가능성           | 적용 사례                   |
|--------|---------|-----|------------------|-------------------------|
| 2PC    | 강한 일관성  | 낮음  | 장애 발생 시 복구 어려움   | 금융, 강한 데이터 일관성이 필요한 서비스 |
| SAGA   | 최종 일관성  | 높음  | 부분 실패 복구 가능      | 이커머스, 주문 시스템            |
| 이벤트 기반 | 최종 일관성  | 높음  | 복구 가능 (이벤트 리플레이) | 데이터 동기화, 비동기 처리         |

### **적용 전략**

1. **결제가 포함된 핵심 트랜잭션 (ex. 결제 승인, 주문 확정)** → **2PC** 적용
2. **대량 처리가 필요한 트랜잭션 (ex. 주문 생성, 쿠폰 사용)** → **SAGA 패턴** 적용
3. **비동기 데이터 동기화 (ex. 인기 상품 조회, 주문 상태 변경)** → **이벤트 기반 아키텍처** 활용

---

## **6. 결론**

MSA 환경에서의 트랜잭션 처리는 모놀리식 아키텍처에서 제공하는 강한 일관성을 유지하기 어려우므로, 분산 환경에 맞는 해결 방안을 적용해야 한다.

2PC는 강한 일관성을 보장하지만 성능 이슈가 존재하며, SAGA 패턴은 확장성이 높지만 보상 트랜잭션 설계가 필요하다. 따라서, 서비스의 특성에 맞는 트랜잭션 관리 전략을 선택하여 효율적으로 시스템을 운영하는 것이 중요하다.

- **강한 일관성이 필요한 경우 2PC 적용** (ex. 결제 승인, 환불 등)
- **트랜잭션의 유연성이 필요한 경우 SAGA 패턴 활용** (ex. 주문 처리, 쿠폰 사용)
- **비동기 트랜잭션 처리에는 이벤트 기반 아키텍처 활용**

위 설계를 통해 **MSA 환경에서도 최적의 트랜잭션 처리 방안을 적용**할 수 있다.